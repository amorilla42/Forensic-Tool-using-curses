import curses
import sqlite3
import os


from utils.guid_aliases import traducir_guids
from .renderizable import Renderizable


def show_scrollable_popup(win, text, title=" Detalles ", footer=" ↑/↓ para desplazarse, ESC para salir "):
    max_y, max_x = win.getmaxyx()
    popup = curses.newwin(max_y, max_x, 3, 0)
    popup.keypad(True)

    lines = text.split("\n")
    header_line = lines[0] if lines else ""
    body_lines = lines[1:] if len(lines) > 1 else []

    scroll_offset = 0
    cursor_index = 0
    content_height = max_y - 3  # sin header y footer

    while True:
        popup.clear()
        popup.box()
        popup.addstr(0, max(1, (max_x - len(title)) // 2), title[:max_x - 2])
        popup.addstr(max_y - 1, max(1, (max_x - len(footer)) // 2), footer[:max_x - 2])

        popup.addstr(1, 2, header_line[:max_x - 4], curses.A_BOLD | curses.A_UNDERLINE)

        visible_lines = body_lines[scroll_offset:scroll_offset + content_height]

        for i, line in enumerate(visible_lines):
            attr = curses.A_REVERSE if i == cursor_index else curses.A_NORMAL
            popup.addstr(i + 2, 2, line[:max_x - 4], attr)

        popup.refresh()
        key = popup.getch()

        if key in [27, ord("q")]:
            break
        elif key == curses.KEY_UP:
            if cursor_index > 0:
                cursor_index -= 1
            elif scroll_offset > 0:
                scroll_offset -= 1
        elif key == curses.KEY_DOWN:
            if cursor_index < len(visible_lines) - 1:
                cursor_index += 1
            elif scroll_offset + content_height < len(body_lines):
                scroll_offset += 1


def format_userassist_table(lines, screen_width=120):
    tipo_w = int(screen_width * 0.20)
    ruta_w = int(screen_width * 0.55)
    count_w = int(screen_width * 0.08)
    tiempo_w = screen_width - (tipo_w + ruta_w + count_w + 9)

    output = []
    header = f"{'Tipo':<{tipo_w}}│ {'Ruta / Identificador':<{ruta_w}}│ {'Veces':^{count_w}} │ {'Última ejecución':<{tiempo_w}}"
    separator = "─" * min(screen_width, len(header))
    output.append(header)
    output.append(separator)

    for line in lines:
        parsed = parse_userassist_line(line)
        if parsed:
            tipo, ruta, count, tiempo = parsed
            output.append(f"{tipo:<{tipo_w}}│ {ruta:<{ruta_w}}│ {count:^{count_w}} │ {tiempo:<{tiempo_w}}")

    return "\n".join(output)


def parse_userassist_line(line):
    try:
        partes = [x.strip() for x in line.rsplit(",", 2)]
        if len(partes) != 3:
            return None
        name, count, tiempo = partes

        if "Microsoft.AutoGenerated" in name:
            return None


        # Separar tipo/ruta si hay ':', si no, todo el nombre va a "ruta"
        if ":" in name:
            prefix, ruta = name.split(":", 1)
        else:
            prefix = name
            ruta = ""

        # Clasificación del tipo
        if prefix.startswith("UEME_CTL"):
            tipo = "UEME_CTL*"
        elif prefix.startswith("J:\\"):
            tipo = "J"
            ruta = prefix  # la ruta completa es lo importante aquí
        elif prefix.startswith("C:\\") or ".lnk" in prefix.lower() or ".exe" in prefix.lower():
            tipo = "C"
            ruta = prefix
        else:
            tipo = prefix  # fallback genérico

        ruta_legible = traducir_guids(ruta.strip())


        return tipo.strip(), ruta_legible, count.strip(), tiempo.strip()
    except Exception:
        return None



def is_printable(s):
    import string
    return all(c in string.printable for c in s)


def format_recent_docs_table(rows, screen_width=120):
    ext_w = int(screen_width * 0.15)
    nombre_w = screen_width - ext_w - 5

    output = []
    header = f"{'Extensión':<{ext_w}}│ {'Nombre del documento':<{nombre_w}}"
    separator = "─" * len(header)
    output.append(header)
    output.append(separator)

    rows = [r for r in rows if all(r) and is_printable(r[1])]
    rows = list(dict.fromkeys(rows))

    normalized = []
    for ext, name in rows:
        if ext.lower() == "folder":
            ext = "Carpeta"
        normalized.append((ext, name))

    for ext, name in normalized:
        output.append(f"{ext:<{ext_w}}│ {name:<{nombre_w}}")

    return "\n".join(output)





def format_mountpoints2_table(rows, screen_width=120):
    from utils.guid_aliases import traducir_guids

    def is_guid(text):
        return (
            isinstance(text, str)
            and text.startswith("{")
            and text.endswith("}")
            and len(text) >= 36
        )

    output = []
    header = f"{'Identificador / Ruta':<{screen_width - 4}}"
    separator = "─" * len(header)
    output.append(header)
    output.append(separator)

    vistos = set()
    rutas_traducidas = []

    for ruta, _, _ in rows:
        if ruta is None or str(ruta).strip() == "":
            continue
        ruta_str = str(ruta).strip()
        if ruta_str in vistos:
            continue
        vistos.add(ruta_str)

        traducida = traducir_guids(ruta_str)
        rutas_traducidas.append((ruta_str, traducida))

    # Ordenar: primero alias legibles, luego GUID puros
    rutas_traducidas.sort(key=lambda x: is_guid(x[1]))

    for _, traducida in rutas_traducidas:
        output.append(f"{traducida:<{screen_width - 4}}")

    return "\n".join(output)

def recortar_columna_shellbag_table(texto, ancho):
    return texto if len(texto) <= ancho else texto[:ancho-1] + "…"

def format_shellbags_table(rows, screen_width=120, selected_index=None, show_popup=False, win=None):
    """
    Muestra la tabla de ShellBags con columnas recortadas.
    Si show_popup=True y win no es None, abre un popup con la fila seleccionada.
    """
    path_w = int(screen_width * 0.35)
    key_w = int(screen_width * 0.40)
    time_w = screen_width - (path_w + key_w + 6)

    output = []
    header = f"{'Ruta':<{path_w}}│ {'Clave de registro':<{key_w}}│ {'Marca de tiempo':<{time_w}}"
    separator = "─" * len(header)
    output.append(header)
    output.append(separator)

    for idx, row in enumerate(rows):
        if len(row) != 4:
            continue
        _, path, key_path, timestamp = map(str, row)

        # Recortar para que encaje en la tabla
        path_col = recortar_columna_shellbag_table(path.replace("\n", " "), path_w)
        key_col = recortar_columna_shellbag_table(key_path, key_w)
        time_col = recortar_columna_shellbag_table(timestamp, time_w)

        output.append(f"{path_col:<{path_w}}│ {key_col:<{key_w}}│ {time_col:<{time_w}}")

    # Mostrar popup de detalle si procede
    if show_popup and win is not None and selected_index is not None and 0 <= selected_index < len(rows):
        import textwrap
        _, full_path, full_key, full_time = map(str, rows[selected_index])

        max_y, max_x = win.getmaxyx()
        wrap_width = max_x - 4  # margen para bordes del popup

        full_path_wrapped = textwrap.fill(full_path, width=wrap_width)
        full_key_wrapped = textwrap.fill(full_key, width=wrap_width)
        full_time_wrapped = textwrap.fill(full_time, width=wrap_width)

        contenido = (
            f"Ruta completa:\n{full_path_wrapped}\n\n"
            f"Clave de registro:\n{full_key_wrapped}\n\n"
            f"Marca de tiempo:\n{full_time_wrapped}"
        )
        show_scrollable_popup(win, contenido, "Detalle ShellBag")

    return "\n".join(output)





def recortar_columna_mru(texto, ancho):
    return texto if len(texto) <= ancho else texto[:ancho-1] + "…"

def format_mru_table(rows, screen_width=120, selected_index=None, show_popup=False, win=None):
    tipo_w = int(screen_width * 0.10)
    nombre_w = int(screen_width * 0.30)
    key_w = int(screen_width * 0.35)
    time_w = screen_width - (tipo_w + nombre_w + key_w + 6)

    output = []
    header = f"{'Tipo MRU':<{tipo_w}}│ {'Nombre archivo':<{nombre_w}}│ {'Clave registro':<{key_w}}│ {'Timestamp':<{time_w}}"
    separator = "─" * len(header)
    output.append(header)
    output.append(separator)

    for idx, row in enumerate(rows):
        if len(row) != 6:
            continue
        _, mru_type, _, name, key_path, timestamp = map(str, row)  # ignoramos extensión

        tipo_col = recortar_columna_mru(mru_type, tipo_w)
        name_col = recortar_columna_mru(name, nombre_w)
        key_col = recortar_columna_mru(key_path, key_w)
        time_col = recortar_columna_mru(timestamp, time_w)

        output.append(f"{tipo_col:<{tipo_w}}│ {name_col:<{nombre_w}}│ {key_col:<{key_w}}│ {time_col:<{time_w}}")

    # POPUP opcional
    if show_popup and win and selected_index is not None and 0 <= selected_index < len(rows):
        import textwrap
        _, mru_type, _, name, key_path, timestamp = map(str, rows[selected_index])
        max_y, max_x = win.getmaxyx()
        wrap = lambda t: textwrap.fill(t, max_x - 4)

        detalle = (
            f"Tipo MRU:\n{mru_type}\n\n"
            f"Nombre del archivo:\n{wrap(name)}\n\n"
            f"Clave de registro:\n{wrap(key_path)}\n\n"
            f"Timestamp:\n{timestamp}"
        )
        show_scrollable_popup(win, detalle, title="Detalle MRU")

    return "\n".join(output)





class UserntDataViewer(Renderizable):
    def __init__(self, win, db_path, export_path, layout):
        self.win = win
        self.db_path = db_path
        self.users = []
        self.selected_index = 0
        self.scroll_offset = 0
        self.show_system_entries = False
        self.export_path = export_path
        self.layout = layout
        self._load_users()

    def _load_users(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT username FROM users ORDER BY username")
        self.users = [row[0] for row in cursor.fetchall()]
        conn.close()

    def clear(self):
        self.win.clear()

    def render(self):
        self.clear()
        max_y, max_x = self.win.getmaxyx()
        visible_height = max_y - 2

        if self.selected_index < self.scroll_offset:
            self.scroll_offset = self.selected_index
        elif self.selected_index >= self.scroll_offset + visible_height:
            self.scroll_offset = self.selected_index - visible_height + 1

        visible_entries = self.users[self.scroll_offset:self.scroll_offset + visible_height]

        self.win.addstr(0, 3, "Usuarios disponibles (ENTER para ver resumen)", curses.A_BOLD)
        for idx, username in enumerate(visible_entries):
            screen_idx = idx + 1
            entry_idx = self.scroll_offset + idx
            if entry_idx == self.selected_index:
                self.win.addstr(screen_idx, 3, username[:max_x - 4], curses.A_REVERSE)
            else:
                self.win.addstr(screen_idx, 3, username[:max_x - 4])

        self.win.refresh()

    def handle_input(self, key):
        total_items = len(self.users)

        if key == curses.KEY_DOWN:
            self.selected_index = min(self.selected_index + 1, total_items - 1)
        elif key == curses.KEY_UP:
            self.selected_index = max(self.selected_index - 1, 0)
        elif key in [10, 13]:  # ENTER
            self._show_user_menu(self.users[self.selected_index])

    def _show_user_menu(self, username):
        options = [
            "Programas ejecutados (Menú Inicio)",
            "Documentos recientes",
            "Comandos ejecutados (Win+R)",
            "Dispositivos conectados (USB y similares)",
            "Archivos abiertos/guardados recientemente",
            "Ejecuciones visualizadas por Explorer",
            "ShellBags",
            "MRU (archivos usados recientemente)",
            "TrayNotify: ejecutables e información del systray",
            "TrayNotify: metadatos de entradas del systray"
        ]
        self.layout.change_footer("ESC: Salir, ↑/↓: Navegar, ENTER: Ver resumen de usuario, e: Exportar informacion, s: Activar/Desactivar entradas del sistema en MuiCache")

        selected = 0
        while True:
            self.clear()
            max_y, max_x = self.win.getmaxyx()
            self.win.addstr(0, 2, f"Resumen para: {username}", curses.A_BOLD)
            self.win.addstr(1, 2, "Selecciona una categoría:", curses.A_UNDERLINE)

            for i, option in enumerate(options):
                attr = curses.A_REVERSE if i == selected else curses.A_NORMAL
                self.win.addstr(i + 3, 4, option, attr)

            self.win.refresh()
            key = self.win.getch()

            if key == curses.KEY_UP:
                selected = (selected - 1) % len(options)
            elif key == curses.KEY_DOWN:
                selected = (selected + 1) % len(options)
            elif key in [10, 13]:
                if selected < len(options):
                    self._show_category_data(username, selected)
            elif key in [27, ord("q")]:
                self.layout.change_footer("ESC: Salir, ↑/↓: Navegar, ENTER: Ver resumen de usuario")
                break
            elif key == ord("e"):
                self._export_user_data(username)
            elif key == ord("s"):
                self.show_system_entries = not self.show_system_entries

    def _show_category_data(self, username, index):
        mapping = [
            ("userassist", "name, run_count, last_run_time"),
            ("recent_docs", "extension, document_name"),
            ("run_mru", "order_key, command"),
            ("mountpoints2", "key_name, volume_label, data"),
            ("open_save_mru", "extension, entry_name, path"),
            ("muicache", "entry_name, description"),
            ("shellbags", "user, path, key_path, timestamp"),
            ("mru_entries", "user, mru_type, extension, file_name, key_path, timestamp"),
            ("traynotify_executables", "user, source, exe_name, extension_type, suspicious, key_path, timestamp"),
            ("traynotify_metadata", "user, value_name, data, key_path, timestamp")
        ]

        table, fields = mapping[index]
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        user_field_per_table = {
            "userassist": "username",
            "recent_docs": "username",
            "run_mru": "username",
            "mountpoints2": "username",
            "open_save_mru": "username",
            "muicache": "username",
            "shellbags": "user",
            "mru_entries": "user",
            "traynotify_executables": "user",
            "traynotify_metadata": "user"
        }

        campo_usuario = user_field_per_table.get(table, "username")
        cursor.execute(f"SELECT {fields} FROM {table} WHERE {campo_usuario}=?", (username,))

        rows = cursor.fetchall()
        conn.close()

        section_titles = [
            "Programas ejecutados desde Menú Inicio",
            "Documentos abiertos recientemente",
            "Comandos lanzados con Win+R",
            "Dispositivos externos conectados",
            "Archivos recientes en diálogos Abrir/Guardar",
            "Programas visualizados en Explorer (MuiCache)",
            "ShellBags",
            "MRU (archivos usados recientemente)",
            "TrayNotify: ejecutables e información del systray",
            "TrayNotify: metadatos de entradas del systray"
        ]

        if index == 0:
            max_y, max_x = self.win.getmaxyx()
            #TODO: BORRAR DESPUES
            from forensic_core.artifact_extractor import extraer_artefactos
            extraer_artefactos(self.db_path, os.path.dirname(self.db_path))
            info = format_userassist_table([", ".join(str(col) for col in row) for row in rows], screen_width=max_x - 4)
        
        elif index == 1:
            max_y, max_x = self.win.getmaxyx()
            rows = [r for r in rows if all(r)]  # elimina vacíos
            rows = list(dict.fromkeys(rows))   # elimina duplicados manteniendo orden
            info = format_recent_docs_table(rows, screen_width=max_x - 4)

        elif index == 3:
            max_y, max_x = self.win.getmaxyx()
            rows = list(dict.fromkeys(rows))   # elimina duplicados manteniendo orden
            info = format_mountpoints2_table(rows, screen_width=max_x - 4)
        
        elif index == 6:  # ShellBags
            selected = 0
            scroll_offset = 0
            while True:
                self.win.clear()
                max_y, max_x = self.win.getmaxyx()
                self.win.box()
                
                header_text = " ShellBags "
                self.win.addstr(0, (max_x - len(header_text)) // 2, header_text, curses.A_BOLD)

                footer_text = " ↑/↓: Navegar  ENTER: Detalle  ESC: Salir "
                self.win.addstr(max_y - 1, (max_x - len(footer_text)) // 2, footer_text, curses.A_BOLD)

                tabla = format_shellbags_table(rows, screen_width=max_x - 4)
                lineas = tabla.split("\n")

                visible_height = max_y - 2  # sin header/footer

                if selected < scroll_offset:
                    scroll_offset = selected
                elif selected >= scroll_offset + visible_height:
                    scroll_offset = selected - visible_height + 1

                visibles = lineas[scroll_offset:scroll_offset + visible_height]

                for idx, line in enumerate(visibles):
                    y = idx + 1
                    if scroll_offset + idx == selected:
                        self.win.addstr(y, 2, line[:max_x - 4], curses.A_REVERSE)
                    else:
                        self.win.addstr(y, 2, line[:max_x - 4])

                self.win.refresh()
                key = self.win.getch()

                if key == curses.KEY_UP:
                    selected = (selected - 1) % len(rows)
                elif key == curses.KEY_DOWN:
                    selected = (selected + 1) % len(rows)
                elif key in (10, 13):  # ENTER
                    format_shellbags_table(rows, screen_width=max_x - 4, selected_index=selected -2, show_popup=True, win=self.win)
                elif key in (27, ord("q")):
                    return

        elif index == 7:  # MRU entries
            selected = 0
            while True:
                self.win.clear()
                max_y, max_x = self.win.getmaxyx()
                self.win.box()

                self.win.addstr(0, (max_x - len(" MRU ")) // 2, " MRU ", curses.A_BOLD)
                self.win.addstr(max_y - 1, (max_x - len(" ↑/↓: Navegar  ENTER: Detalle  ESC: Salir ")) // 2,
                                " ↑/↓: Navegar  ENTER: Detalle  ESC: Salir ", curses.A_BOLD)

                tabla = format_mru_table(rows, screen_width=max_x - 4, selected_index=selected)

                for idx, line in enumerate(tabla.split("\n")):
                    y = idx + 1
                    if idx - 2 == selected:
                        self.win.addstr(y, 2, line, curses.A_REVERSE)
                    else:
                        self.win.addstr(y, 2, line)

                self.win.refresh()
                key = self.win.getch()

                if key == curses.KEY_UP:
                    selected = (selected - 1) % len(rows)
                elif key == curses.KEY_DOWN:
                    selected = (selected + 1) % len(rows)
                elif key in (10, 13):
                    format_mru_table(rows, screen_width=max_x - 4, selected_index=selected, show_popup=True, win=self.win)
                elif key in (27, ord("q")):
                    return

        else:
            info = f" {section_titles[index]} \nUsuario: {username}\n\n"
            if not rows:
                info += "(Sin datos disponibles)"
            else:
                for row in rows:
                    if index == 5 and not self.show_system_entries:
                        if str(row[0]).lower().startswith("@shell32.dll") or str(row[0]).lower().startswith("@c:\\windows"):
                            continue
                    info += ", ".join(str(col) for col in row) + "\n"

        show_scrollable_popup(self.win, info, section_titles[index])
        self.layout.change_header("Informacion general de los usuarios disponibles")
        self.layout.change_footer("ESC: Salir, ↑/↓: Navegar, ENTER: Ver resumen de usuario, e: Exportar informacion, s: Activar/Desactivar entradas del sistema en MuiCache")


    def _export_user_data(self, username):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        sections = [
            ("userassist", "Programas ejecutados desde Menú Inicio", "name, run_count, last_run_time"),
            ("recent_docs", "Documentos abiertos recientemente", "extension, document_name"),
            ("run_mru", "Comandos lanzados con Win+R", "order_key, command"),
            ("mountpoints2", "Dispositivos externos conectados", "key_name, volume_label, data"),
            ("open_save_mru", "Archivos recientes en diálogos Abrir/Guardar", "extension, entry_name, path"),
            ("muicache", "Programas visualizados en Explorer (MuiCache)", "entry_name, description"),
            ("shellbags", "ShellBags", "user, path, key_path, timestamp"),
            ("mru_entries", "MRU (archivos usados recientemente)", "user, mru_type, extension, file_name, key_path, timestamp"),
            ("traynotify_executables", "TrayNotify: ejecutables e información del systray", "user, source, exe_name, extension_type, suspicious, key_path, timestamp"),
            ("traynotify_metadata", "TrayNotify: metadatos de entradas del systray", "user, value_name, data, key_path, timestamp")
        ]

        user_field_per_table = {
            "userassist": "username",
            "recent_docs": "username",
            "run_mru": "username",
            "mountpoints2": "username",
            "open_save_mru": "username",
            "muicache": "username",
            "shellbags": "user",
            "mru_entries": "user",
            "traynotify_executables": "user",
            "traynotify_metadata": "user"
        }

        output = f"Resumen forense de usuario: {username}\n\n"
        for table, title, fields in sections:
            campo_usuario = user_field_per_table.get(table, "username")
            cursor.execute(f"SELECT {fields} FROM {table} WHERE {campo_usuario}=?", (username,))
            rows = cursor.fetchall()
            output += f"== {title} ==\n"
            if not rows:
                output += "(Sin datos disponibles)\n"
            else:
                for row in rows:
                    if table == "muicache" and not self.show_system_entries:
                        if str(row[0]).lower().startswith("@shell32.dll") or str(row[0]).lower().startswith("@c:\\windows"):
                            continue
                    output += ", ".join(str(col) for col in row) + "\n"
            output += "\n"

        conn.close()

        os.makedirs(self.export_path, exist_ok=True)
        filename = f"{self.export_path}/{username}_forensic_report.txt"
        with open(filename, "w", encoding="utf-8") as f:
            f.write(output)

        show_scrollable_popup(self.win, f"Datos exportados correctamente a:\n{filename}", "Exportación exitosa")
        self.layout.change_header("Informacion general de los usuarios disponibles")
        self.layout.change_footer("ESC: Salir, ↑/↓: Navegar, ENTER: Ver resumen de usuario, e: Exportar informacion, s: Activar/Desactivar entradas del sistema en MuiCache")
