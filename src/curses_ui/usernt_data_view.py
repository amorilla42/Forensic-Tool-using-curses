import curses
import sqlite3
import os


from utils.guid_aliases import traducir_guids
from .renderizable import Renderizable


def show_scrollable_popup(win, text, title=" Detalles ", footer=" ↑/↓ para desplazarse, ESC para salir "):
    max_y, max_x = win.getmaxyx()
    popup = curses.newwin(max_y, max_x, 3, 0)
    popup.keypad(True)

    lines = text.split("\n")
    header_line = lines[0] if lines else ""
    body_lines = lines[1:] if len(lines) > 1 else []

    scroll_offset = 0
    cursor_index = 0
    content_height = max_y - 3  # sin header y footer

    while True:
        popup.clear()
        popup.box()
        popup.addstr(0, max(1, (max_x - len(title)) // 2), title[:max_x - 2])
        popup.addstr(max_y - 1, max(1, (max_x - len(footer)) // 2), footer[:max_x - 2])

        popup.addstr(1, 2, header_line[:max_x - 4], curses.A_BOLD | curses.A_UNDERLINE)

        visible_lines = body_lines[scroll_offset:scroll_offset + content_height]

        for i, line in enumerate(visible_lines):
            attr = curses.A_REVERSE if i == cursor_index else curses.A_NORMAL
            popup.addstr(i + 2, 2, line[:max_x - 4], attr)

        popup.refresh()
        key = popup.getch()

        if key in [27, ord("q")]:
            break
        elif key == curses.KEY_UP:
            if cursor_index > 0:
                cursor_index -= 1
            elif scroll_offset > 0:
                scroll_offset -= 1
        elif key == curses.KEY_DOWN:
            if cursor_index < len(visible_lines) - 1:
                cursor_index += 1
            elif scroll_offset + content_height < len(body_lines):
                scroll_offset += 1


def format_userassist_table(lines, screen_width=120):
    tipo_w = int(screen_width * 0.20)
    ruta_w = int(screen_width * 0.55)
    count_w = int(screen_width * 0.08)
    tiempo_w = screen_width - (tipo_w + ruta_w + count_w + 9)

    output = []
    header = f"{'Tipo':<{tipo_w}}│ {'Ruta / Identificador':<{ruta_w}}│ {'Veces':^{count_w}} │ {'Última ejecución':<{tiempo_w}}"
    separator = "─" * min(screen_width, len(header))
    output.append(header)
    output.append(separator)

    for line in lines:
        parsed = parse_userassist_line(line)
        if parsed:
            tipo, ruta, count, tiempo = parsed
            output.append(f"{tipo:<{tipo_w}}│ {ruta:<{ruta_w}}│ {count:^{count_w}} │ {tiempo:<{tiempo_w}}")

    return "\n".join(output)


def parse_userassist_line(line):
    try:
        partes = [x.strip() for x in line.rsplit(",", 2)]
        if len(partes) != 3:
            return None
        name, count, tiempo = partes

        if "Microsoft.AutoGenerated" in name:
            return None


        # Separar tipo/ruta si hay ':', si no, todo el nombre va a "ruta"
        if ":" in name:
            prefix, ruta = name.split(":", 1)
        else:
            prefix = name
            ruta = ""

        # Clasificación del tipo
        if prefix.startswith("UEME_CTL"):
            tipo = "UEME_CTL*"
        elif prefix.startswith("J:\\"):
            tipo = "J"
            ruta = prefix  # la ruta completa es lo importante aquí
        elif prefix.startswith("C:\\") or ".lnk" in prefix.lower() or ".exe" in prefix.lower():
            tipo = "C"
            ruta = prefix
        else:
            tipo = prefix  # fallback genérico

        ruta_legible = traducir_guids(ruta.strip())


        return tipo.strip(), ruta_legible, count.strip(), tiempo.strip()
    except Exception:
        return None



def is_printable(s):
    import string
    return all(c in string.printable for c in s)


def format_recent_docs_table(rows, screen_width=120):
    ext_w = int(screen_width * 0.15)
    nombre_w = screen_width - ext_w - 5

    output = []
    header = f"{'Extensión':<{ext_w}}│ {'Nombre del documento':<{nombre_w}}"
    separator = "─" * len(header)
    output.append(header)
    output.append(separator)

    rows = [r for r in rows if all(r) and is_printable(r[1])]
    rows = list(dict.fromkeys(rows))

    normalized = []
    for ext, name in rows:
        if ext.lower() == "folder":
            ext = "Carpeta"
        normalized.append((ext, name))

    for ext, name in normalized:
        output.append(f"{ext:<{ext_w}}│ {name:<{nombre_w}}")

    return "\n".join(output)





def format_mountpoints2_table(rows, screen_width=120):
    from utils.guid_aliases import traducir_guids

    def is_guid(text):
        return (
            isinstance(text, str)
            and text.startswith("{")
            and text.endswith("}")
            and len(text) >= 36
        )

    output = []
    header = f"{'Identificador / Ruta':<{screen_width - 4}}"
    separator = "─" * len(header)
    output.append(header)
    output.append(separator)

    vistos = set()
    rutas_traducidas = []

    for ruta, _, _ in rows:
        if ruta is None or str(ruta).strip() == "":
            continue
        ruta_str = str(ruta).strip()
        if ruta_str in vistos:
            continue
        vistos.add(ruta_str)

        traducida = traducir_guids(ruta_str)
        rutas_traducidas.append((ruta_str, traducida))

    # Ordenar: primero alias legibles, luego GUID puros
    rutas_traducidas.sort(key=lambda x: is_guid(x[1]))

    for _, traducida in rutas_traducidas:
        output.append(f"{traducida:<{screen_width - 4}}")

    return "\n".join(output)

def recortar_columna_shellbag_table(texto, ancho):
    return texto if len(texto) <= ancho else texto[:ancho-1] + "…"




def format_shellbags_table(rows, screen_width=120, selected_index=None, show_popup=False, win=None):
    """
    Muestra la tabla de ShellBags con columnas recortadas.
    Si show_popup=True y win no es None, abre un popup con la fila seleccionada.
    """
    path_w = int(screen_width * 0.35)
    key_w = int(screen_width * 0.40)
    time_w = screen_width - (path_w + key_w + 6)

    output = []
    header = f"{'Ruta':<{path_w}}│ {'Clave de registro':<{key_w}}│ {'Marca de tiempo':<{time_w}}"
    separator = "─" * len(header)
    output.append(header)
    output.append(separator)

    for idx, row in enumerate(rows):
        if len(row) != 4:
            continue
        _, path, key_path, timestamp = map(str, row)

        # Recortar para que encaje en la tabla
        path_col = recortar_columna_shellbag_table(path.replace("\n", " "), path_w)
        key_col = recortar_columna_shellbag_table(key_path, key_w)
        time_col = recortar_columna_shellbag_table(timestamp, time_w)

        output.append(f"{path_col:<{path_w}}│ {key_col:<{key_w}}│ {time_col:<{time_w}}")

    # Mostrar popup de detalle si procede
    if show_popup and win is not None and selected_index is not None and 0 <= selected_index < len(rows):
        import textwrap
        _, full_path, full_key, full_time = map(str, rows[selected_index])

        max_y, max_x = win.getmaxyx()
        wrap_width = max_x - 4  # margen para bordes del popup

        full_path_wrapped = textwrap.fill(full_path, width=wrap_width)
        full_key_wrapped = textwrap.fill(full_key, width=wrap_width)
        full_time_wrapped = textwrap.fill(full_time, width=wrap_width)

        contenido = (
            f"Ruta completa:\n{full_path_wrapped}\n\n"
            f"Clave de registro:\n{full_key_wrapped}\n\n"
            f"Marca de tiempo:\n{full_time_wrapped}"
        )
        show_scrollable_popup(win, contenido, "Detalle ShellBag")

    return "\n".join(output)





def recortar_columna_mru(texto, ancho):
    return texto if len(texto) <= ancho else texto[:ancho-1] + "…"

def format_mru_table(rows, screen_width=120, selected_index=None, show_popup=False, win=None):
    tipo_w = int(screen_width * 0.10)
    nombre_w = int(screen_width * 0.30)
    key_w = int(screen_width * 0.35)
    time_w = screen_width - (tipo_w + nombre_w + key_w + 6)

    output = []
    header = f"{'Tipo MRU':<{tipo_w}}│ {'Nombre archivo':<{nombre_w}}│ {'Clave registro':<{key_w}}│ {'Timestamp':<{time_w}}"
    separator = "─" * len(header)
    output.append(header)
    output.append(separator)

    for idx, row in enumerate(rows):
        if len(row) != 6:
            continue
        _, mru_type, _, name, key_path, timestamp = map(str, row)  # ignoramos extensión

        tipo_col = recortar_columna_mru(mru_type, tipo_w)
        name_col = recortar_columna_mru(name, nombre_w)
        key_col = recortar_columna_mru(key_path, key_w)
        time_col = recortar_columna_mru(timestamp, time_w)

        output.append(f"{tipo_col:<{tipo_w}}│ {name_col:<{nombre_w}}│ {key_col:<{key_w}}│ {time_col:<{time_w}}")

    # POPUP opcional
    if show_popup and win and selected_index is not None and 0 <= selected_index < len(rows):
        import textwrap
        _, mru_type, _, name, key_path, timestamp = map(str, rows[selected_index])
        max_y, max_x = win.getmaxyx()
        wrap = lambda t: textwrap.fill(t, max_x - 4)

        detalle = (
            f"Tipo MRU:\n{mru_type}\n\n"
            f"Nombre del archivo:\n{wrap(name)}\n\n"
            f"Clave de registro:\n{wrap(key_path)}\n\n"
            f"Timestamp:\n{timestamp}"
        )
        show_scrollable_popup(win, detalle, title="Detalle MRU")

    return "\n".join(output)



def filetime_to_str(ft_str):
    """Convierte un FILETIME (en string) a 'YYYY-mm-dd HH:MM:SS' o devuelve el original si no aplica."""
    from datetime import datetime, timedelta
    import re
    # Regex para validar FILETIME: 15-20 dígitos
    FILETIME_RE = re.compile(r"^\d{15,20}$")
    try:
        if ft_str is None:
            return ""
        s = str(ft_str).strip()
        if not FILETIME_RE.match(s):
            return s
        ft = int(s)
        if ft == 0:
            return ""
        dt = datetime(1601, 1, 1) + timedelta(microseconds=ft // 10)
        # sanity check razonable
        if 1980 <= dt.year <= 2100:
            return dt.strftime("%Y-%m-%d %H:%M:%S")
        return s
    except Exception:
        return str(ft_str)

def resolver_traynotify_guids(db_path, guid_string):
    """
    Dada la cadena 'data' con varios GUIDs (separados por comas), intenta
    resolverlos contra tus tablas: installed_components, muicache, app_paths,
    filesystem_entry. Devuelve lista de strings legibles.
    """
    import re
    # Extrae GUIDs entre llaves {....}
    guids = re.findall(r"\{[0-9A-Za-z\-]{36}\}", str(guid_string))
    if not guids:
        return []

    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    resueltos = []

    for g in guids:
        descr = None

        # 1) installed_components (CLSID/AppID conocidos)
        cur.execute("""
            SELECT component_name, stub_path FROM installed_components WHERE component_id=?
        """, (g,))
        row = cur.fetchone()
        if row:
            name, stub = row
            if name:
                descr = f"{name} [{g}]"
            elif stub:
                descr = f"{stub} [{g}]"

        # 2) muicache (a veces contiene rutas/entradas con GUID)
        if not descr:
            cur.execute("""
                SELECT description FROM muicache WHERE entry_name LIKE ?
            """, (f"%{g}%",))
            row = cur.fetchone()
            if row and row[0]:
                descr = f"{row[0]} [{g}]"

        # 3) app_paths (por si el GUID aparece embebido en alguna ruta)
        if not descr:
            cur.execute("""
                SELECT executable, path FROM app_paths WHERE path LIKE ?
            """, (f"%{g}%",))
            row = cur.fetchone()
            if row:
                exe, path = row
                descr = f"{exe} ({path}) [{g}]"

        # 4) filesystem_entry (GUID en rutas del FS)
        if not descr:
            cur.execute("""
                SELECT full_path FROM filesystem_entry WHERE full_path LIKE ?
            """, (f"%{g}%",))
            row = cur.fetchone()
            if row and row[0]:
                descr = f"{row[0]} [{g}]"

        resueltos.append(descr or g)

    conn.close()
    return resueltos



def resolve_tray_data(data, db_path=None):
    """
    - Si es FILETIME → fecha legible
    - Si contiene varios GUID → intenta resolverlos con la DB (si se pasa db_path)
    - Si contiene GUID/rutas → usa traducir_guids como fallback
    """
    import re

    if data is None:
        return ""

    raw = str(data).strip()

    # 1) FILETIME
    human = filetime_to_str(raw)
    if human != raw:
        return human

    # 2) Lista de GUIDs separada por comas
    guids = re.findall(r"\{[0-9A-Za-z\-]{36}\}", raw)
    if guids:
        if db_path:
            resolved = resolver_traynotify_guids(db_path, raw)
            return " | ".join(resolved)
        # sin DB, al menos traduce (si tienes alias)
        try:
            from utils.guid_aliases import traducir_guids
            return " | ".join([traducir_guids(g) for g in guids])
        except Exception:
            return " | ".join(guids)

    # 3) Si parece ruta con GUID embebido, intenta traducir
    try:
        aliased = traducir_guids(raw)
        return aliased
    except Exception:
        return raw    

def recortar_columna(texto, ancho):
    s = "" if texto is None else str(texto).replace("\n", " ")
    return s if len(s) <= ancho else s[:ancho-1] + "…"

def format_traynotify_metadata_table(rows, screen_width=120, selected_index=None, show_popup=False, win=None, db_path=None):
    import textwrap
    name_w = int(screen_width * 0.24)
    data_w = int(screen_width * 0.36)
    key_w  = int(screen_width * 0.24)
    time_w = screen_width - (name_w + data_w + key_w + 6)

    out = []
    header = f"{'Valor':<{name_w}}│ {'Dato (resuelto)':<{data_w}}│ {'Clave registro':<{key_w}}│ {'Timestamp':<{time_w}}"
    sep = "─" * len(header)
    out.append(header)
    out.append(sep)

    for idx, row in enumerate(rows):
        if len(row) != 5:
            continue
        user, value_name, data, key_path, ts = row
        resolved = resolve_tray_data(data, db_path=db_path)

        out.append(
            f"{recortar_columna(value_name, name_w):<{name_w}}│ "
            f"{recortar_columna(resolved,   data_w):<{data_w}}│ "
            f"{recortar_columna(key_path,   key_w):<{key_w}}│ "
            f"{recortar_columna(ts,         time_w):<{time_w}}"
        )

    if show_popup and win is not None and selected_index is not None and 0 <= selected_index < len(rows):
        user, value_name, data, key_path, ts = rows[selected_index]
        resolved = resolve_tray_data(data, db_path=db_path)

        max_y, max_x = win.getmaxyx()
        w = max_x - 4
        wrap = lambda t: textwrap.fill("" if t is None else str(t), width=w)

        contenido = (
            f"Usuario:\n{user}\n\n"
            f"Valor (value_name):\n{wrap(value_name)}\n\n"
            f"Dato (raw):\n{wrap(data)}\n\n"
            f"Dato (resuelto):\n{wrap(resolved)}\n\n"
            f"Clave de registro:\n{wrap(key_path)}\n\n"
            f"Timestamp:\n{wrap(ts)}"
        )
        show_scrollable_popup(win, contenido, "Detalle TrayNotify Metadata")

    return "\n".join(out)




def moz_prtime_to_str(value):
    from datetime import datetime
    """Firefox PRTime → 'YYYY-mm-dd HH:MM:SS' (UTC). PRTime = microsegundos desde Unix epoch."""
    try:
        if value is None:
            return ""
        v = int(value)
        if v <= 0:
            return ""
        return datetime.utcfromtimestamp(v / 1_000_000).strftime("%Y-%m-%d %H:%M:%S")
    except Exception:
        return str(value) if value is not None else ""

def recortar_columna_url(texto, ancho):
    s = "" if texto is None else str(texto).replace("\n", " ")
    return s if len(s) <= ancho else s[:ancho-1] + "…"

def format_firefox_history_table(rows, screen_width=120, selected_index=None, show_popup=False, win=None):
    """
    Tabla: URL | Título | Visitas | Última visita.
    rows: [(url, title, visit_count, last_visit_date), ...]
    """
    url_w   = int(screen_width * 0.42)
    title_w = int(screen_width * 0.35)
    count_w = 8
    time_w  = screen_width - (url_w + title_w + count_w + 7)

    out = []
    header = f"{'URL':<{url_w}}│ {'Título':<{title_w}}│ {'Visitas':^{count_w}} │ {'Última visita (UTC)':<{time_w}}"
    sep = "─" * len(header)
    out.append(header)
    out.append(sep)

    for idx, row in enumerate(rows):
        if len(row) != 4:
            continue
        url, title, visit_count, last_visit_date = row
        out.append(
            f"{recortar_columna_url(url,   url_w):<{url_w}}│ "
            f"{recortar_columna_url(title, title_w):<{title_w}}│ "
            f"{str(visit_count or 0):^{count_w}} │ "
            f"{recortar_columna_url(moz_prtime_to_str(last_visit_date), time_w):<{time_w}}"
        )

    if show_popup and win is not None and selected_index is not None and 0 <= selected_index < len(rows):
        import textwrap
        url, title, visit_count, last_visit_date = rows[selected_index]
        max_y, max_x = win.getmaxyx()
        w = max_x - 4
        contenido = (
            f"URL:\n{textwrap.fill(str(url or ''), width=w)}\n\n"
            f"Título:\n{textwrap.fill(str(title or ''), width=w)}\n\n"
            f"Visitas: {visit_count or 0}\n\n"
            f"Última visita (UTC): {moz_prtime_to_str(last_visit_date)}"
        )
        show_scrollable_popup(win, contenido, "Detalle historial Firefox")

    return "\n".join(out)






class UserntDataViewer(Renderizable):
    def __init__(self, win, db_path, export_path, layout):
        self.win = win
        self.db_path = db_path
        self.users = []
        self.selected_index = 0
        self.scroll_offset = 0
        self.show_system_entries = False
        self.export_path = export_path
        self.layout = layout
        self._load_users()
        self.shellbags_scope = "user" # "user" | "system" | "all"

    def _load_users(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT username FROM users ORDER BY username")
        self.users = [row[0] for row in cursor.fetchall()]
        conn.close()

    def clear(self):
        self.win.clear()

    def render(self):
        self.clear()
        max_y, max_x = self.win.getmaxyx()
        visible_height = max_y - 2

        if self.selected_index < self.scroll_offset:
            self.scroll_offset = self.selected_index
        elif self.selected_index >= self.scroll_offset + visible_height:
            self.scroll_offset = self.selected_index - visible_height + 1

        visible_entries = self.users[self.scroll_offset:self.scroll_offset + visible_height]

        self.win.addstr(0, 3, "Usuarios disponibles (ENTER para ver resumen)", curses.A_BOLD)
        for idx, username in enumerate(visible_entries):
            screen_idx = idx + 1
            entry_idx = self.scroll_offset + idx
            if entry_idx == self.selected_index:
                self.win.addstr(screen_idx, 3, username[:max_x - 4], curses.A_REVERSE)
            else:
                self.win.addstr(screen_idx, 3, username[:max_x - 4])

        self.win.refresh()

    def handle_input(self, key):
        total_items = len(self.users)

        if key == curses.KEY_DOWN:
            self.selected_index = min(self.selected_index + 1, total_items - 1)
        elif key == curses.KEY_UP:
            self.selected_index = max(self.selected_index - 1, 0)
        elif key in [10, 13]:  # ENTER
            self._show_user_menu(self.users[self.selected_index])

    def _get_shellbags_rows(self, cursor, username, scope):
        if scope == "user":
            cursor.execute("SELECT user, path, key_path, timestamp FROM shellbags WHERE user=? AND (path NOT LIKE '%.dll%' AND path NOT LIKE '%System32%' AND path NOT LIKE '%Windows%')", (username,))
        elif scope == "system":
            cursor.execute("SELECT user, path, key_path, timestamp FROM shellbags WHERE user= ? AND (path LIKE '%.dll%' OR path LIKE '%System32%' OR path LIKE '%Windows%')", (username,))
        else:  # "all"
            cursor.execute("SELECT user, path, key_path, timestamp FROM shellbags")
        return cursor.fetchall()


    def _show_user_menu(self, username):
        options = [
            "Programas ejecutados (Menú Inicio)",
            "Documentos recientes",
            "Comandos ejecutados (Win+R)",
            "Dispositivos conectados (USB y similares)",
            "Archivos abiertos/guardados recientemente",
            "Ejecuciones visualizadas por Explorer",
            "ShellBags",
            "MRU (archivos usados recientemente)",
            "TrayNotify: ejecutables e información del systray",
            "TrayNotify: metadatos de entradas del systray",
            "Historial de navegador (Firefox)" 
        ]
        self.layout.change_footer("ESC: Salir, ↑/↓: Navegar, ENTER: Ver resumen de usuario, e: Exportar informacion del usuario")

        selected = 0
        while True:
            self.clear()
            max_y, max_x = self.win.getmaxyx()
            self.win.addstr(0, 2, f"Resumen para: {username}", curses.A_BOLD)
            self.win.addstr(1, 2, "Selecciona una categoría:", curses.A_UNDERLINE)

            for i, option in enumerate(options):
                attr = curses.A_REVERSE if i == selected else curses.A_NORMAL
                self.win.addstr(i + 3, 4, option, attr)

            self.win.refresh()
            key = self.win.getch()

            if key == curses.KEY_UP:
                selected = (selected - 1) % len(options)
            elif key == curses.KEY_DOWN:
                selected = (selected + 1) % len(options)
            elif key in [10, 13]:
                if selected < len(options):
                    self._show_category_data(username, selected)
            elif key in [27, ord("q")]:
                self.layout.change_footer("ESC: Salir, ↑/↓: Navegar, ENTER: Ver resumen de usuario")
                break
            elif key == ord("e"):
                self._export_user_data(username)
            elif key == ord("s"):
                self.show_system_entries = not self.show_system_entries

    def _show_category_data(self, username, index):
        mapping = [
            ("userassist", "name, run_count, last_run_time"),
            ("recent_docs", "extension, document_name"),
            ("run_mru", "order_key, command"),
            ("mountpoints2", "key_name, volume_label, data"),
            ("open_save_mru", "extension, entry_name, path"),
            ("muicache", "entry_name, description"),
            ("shellbags", "user, path, key_path, timestamp"),
            ("mru_entries", "user, mru_type, extension, file_name, key_path, timestamp"),
            ("traynotify_executables", "user, source, exe_name, extension_type, suspicious, key_path, timestamp"),
            ("traynotify_metadata", "user, value_name, data, key_path, timestamp"),
            ("firefox_history", "url, title, visit_count, last_visit_date")
        ]

        table, fields = mapping[index]
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        user_field_per_table = {
            "userassist": "username",
            "recent_docs": "username",
            "run_mru": "username",
            "mountpoints2": "username",
            "open_save_mru": "username",
            "muicache": "username",
            "shellbags": "user",
            "mru_entries": "user",
            "traynotify_executables": "user",
            "traynotify_metadata": "user",
            "firefox_history": "username" 
        }

        campo_usuario = user_field_per_table.get(table, "username")
        cursor.execute(f"SELECT {fields} FROM {table} WHERE {campo_usuario}=?", (username,))

        rows = cursor.fetchall()
        conn.close()

        section_titles = [
            "Programas ejecutados desde Menú Inicio",
            "Documentos abiertos recientemente",
            "Comandos lanzados con Win+R",
            "Dispositivos externos conectados",
            "Archivos recientes en diálogos Abrir/Guardar",
            "Programas visualizados en Explorer (MuiCache)",
            "ShellBags",
            "MRU (archivos usados recientemente)",
            "TrayNotify: ejecutables e información del systray",
            "TrayNotify: metadatos de entradas del systray",
            "Historial de navegador (Firefox)"
        ]

        if index == 0:
            max_y, max_x = self.win.getmaxyx()
            #TODO: BORRAR DESPUES
            #from forensic_core.artifact_extractor import extraer_artefactos
            #extraer_artefactos(self.db_path, os.path.dirname(self.db_path))
            info = format_userassist_table([", ".join(str(col) for col in row) for row in rows], screen_width=max_x - 4)
        
        elif index == 1: # Documentos recientes
            max_y, max_x = self.win.getmaxyx()
            rows = [r for r in rows if all(r)]  # elimina vacíos
            rows = list(dict.fromkeys(rows))   # elimina duplicados manteniendo orden
            info = format_recent_docs_table(rows, screen_width=max_x - 4)

        elif index == 3: # Dispositivos conectados
            max_y, max_x = self.win.getmaxyx()
            rows = list(dict.fromkeys(rows))   # elimina duplicados manteniendo orden
            info = format_mountpoints2_table(rows, screen_width=max_x - 4)
        
        elif index == 6:  # ShellBags
            selected = 0
            scroll_offset = 0

            self.layout.change_footer("")

            # conexión reutilizable dentro del bucle
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            while True:
                # Carga según alcance actual
                rows = self._get_shellbags_rows(cursor, username, self.shellbags_scope)

                self.win.clear()
                max_y, max_x = self.win.getmaxyx()
                self.win.box()

                # Header con insignia de alcance
                scope_badge = {
                    "user": f"Usuario: {username}",
                    "system": "Sistema",
                    "all": "Todos"
                }[self.shellbags_scope]
                header_text = f" ShellBags [{scope_badge}] "
                self.win.addstr(0, max(2, (max_x - len(header_text)) // 2), header_text, curses.A_BOLD)

                # Footer con ayuda de teclas
                footer_text = " ↑/↓: Navegar  ENTER: Detalle  u: Usuario  s: Sistema  a: Todos  ESC/q: Salir "
                self.win.addstr(max_y - 1, max(2, (max_x - len(footer_text)) // 2), footer_text, curses.A_BOLD)

                # Render tabla (texto) y gestionar scroll/selección a nivel de filas (no líneas)
                tabla = format_shellbags_table(rows, screen_width=max_x - 4)
                lineas = tabla.split("\n")

                # Las 2 primeras líneas son header y separador
                header_lines = 2
                data_lines_total = max(0, len(lineas) - header_lines)

                # Asegura selected dentro de rango
                if rows:
                    selected = max(0, min(selected, len(rows) - 1))
                else:
                    selected = 0

                # Ajuste de scroll: contamos líneas totales visibles (incluye header/separador)
                visible_height = max_y - 2  # sin bordes de caja
                # Para que la fila seleccionada (data_idx) sea visible, calculamos su posición en "lineas"
                selected_line = selected + header_lines  # línea absoluta en 'lineas'

                if selected_line < scroll_offset + header_lines:
                    scroll_offset = selected_line - header_lines
                elif selected_line >= scroll_offset + visible_height:
                    scroll_offset = selected_line - visible_height + 1

                # Clamp scroll
                max_scroll = max(0, len(lineas) - visible_height)
                scroll_offset = max(0, min(scroll_offset, max_scroll))

                # Pintar líneas visibles
                visibles = lineas[scroll_offset:scroll_offset + visible_height]
                for idx, line in enumerate(visibles):
                    y = idx + 1
                    absolute_line = scroll_offset + idx
                    # Marcar solo las filas de datos (a partir de header_lines)
                    if absolute_line >= header_lines:
                        data_idx = absolute_line - header_lines
                        attr = curses.A_REVERSE if data_idx == selected else curses.A_NORMAL
                    else:
                        attr = curses.A_BOLD if absolute_line == 0 else curses.A_NORMAL
                    self.win.addstr(y, 2, line[:max_x - 4], attr)

                self.win.refresh()
                key = self.win.getch()

                if key == curses.KEY_UP:
                    if rows:
                        selected = (selected - 1) % len(rows)
                elif key == curses.KEY_DOWN:
                    if rows:
                        selected = (selected + 1) % len(rows)
                elif key in (10, 13):  # ENTER
                    if rows:
                        format_shellbags_table(rows, screen_width=max_x - 4,
                                            selected_index=selected, show_popup=True, win=self.win)
                elif key in (27, ord("q")):
                    conn.close()
                    self.layout.change_footer("ESC: Salir, ↑/↓: Navegar, ENTER: Ver resumen de usuario, e: Exportar informacion del usuario")
                    return
                elif key == ord("u"):
                    self.shellbags_scope = "user"
                    selected = 0
                    scroll_offset = 0
                elif key == ord("s"):
                    self.shellbags_scope = "system"
                    selected = 0
                    scroll_offset = 0
                elif key == ord("a"):
                    self.shellbags_scope = "all"
                    selected = 0
                    scroll_offset = 0

        elif index == 7:  # MRU entries
            selected = 0
            while True:
                self.win.clear()
                max_y, max_x = self.win.getmaxyx()
                self.win.box()
                self.layout.change_footer("")

                self.win.addstr(0, (max_x - len(" MRU (archivos usados recientemente) ")) // 2, " MRU (archivos usados recientemente) ", curses.A_BOLD)
                self.win.addstr(max_y - 1, (max_x - len(" ↑/↓: Navegar  ENTER: Detalle  ESC: Salir ")) // 2,
                                " ↑/↓: Navegar  ENTER: Detalle  ESC: Salir ", curses.A_BOLD)

                tabla = format_mru_table(rows, screen_width=max_x - 4, selected_index=selected)

                for idx, line in enumerate(tabla.split("\n")):
                    y = idx + 1
                    if idx - 2 == selected:
                        self.win.addstr(y, 2, line, curses.A_REVERSE)
                    else:
                        self.win.addstr(y, 2, line)

                self.win.refresh()
                key = self.win.getch()

                if key == curses.KEY_UP:
                    selected = (selected - 1) % len(rows)
                elif key == curses.KEY_DOWN:
                    selected = (selected + 1) % len(rows)
                elif key in (10, 13):
                    format_mru_table(rows, screen_width=max_x - 4, selected_index=selected, show_popup=True, win=self.win)
                elif key in (27, ord("q")):
                    self.layout.change_footer("ESC: Salir, ↑/↓: Navegar, ENTER: Ver resumen de usuario, e: Exportar informacion del usuario")
                    return
        elif index == 9:  # TrayNotify metadata
            selected = 0
            scroll_offset = 0
            self.layout.change_footer("")

            # Cargamos de nuevo las filas para este usuario
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute(
                "SELECT user, value_name, data, key_path, timestamp FROM traynotify_metadata WHERE user=? ORDER BY timestamp",
                (username,)
            )
            rows = cursor.fetchall()

            while True:
                self.win.clear()
                max_y, max_x = self.win.getmaxyx()
                self.win.box()

                title = " TrayNotify: metadatos de entradas del systray "
                self.win.addstr(0, max(2, (max_x - len(title)) // 2), title, curses.A_BOLD)

                footer = " ↑/↓: Navegar  ENTER: Detalle  ESC/q: Salir "
                self.win.addstr(max_y - 1, max(2, (max_x - len(footer)) // 2), footer, curses.A_BOLD)

                tabla = format_traynotify_metadata_table(rows, screen_width=max_x - 4, db_path=self.db_path)
                lineas = tabla.split("\n")

                header_lines = 2
                visible_height = max_y - 2  # sin bordes
                total_lines = len(lineas)

                # Asegura selected dentro de rango
                if rows:
                    selected = max(0, min(selected, len(rows) - 1))
                else:
                    selected = 0

                selected_line = selected + header_lines

                if selected_line < scroll_offset + header_lines:
                    scroll_offset = selected_line - header_lines
                elif selected_line >= scroll_offset + visible_height:
                    scroll_offset = selected_line - visible_height + 1

                max_scroll = max(0, total_lines - visible_height)
                scroll_offset = max(0, min(scroll_offset, max_scroll))

                visibles = lineas[scroll_offset:scroll_offset + visible_height]
                for i, line in enumerate(visibles):
                    y = i + 1
                    abs_line = scroll_offset + i
                    if abs_line >= header_lines:
                        data_idx = abs_line - header_lines
                        attr = curses.A_REVERSE if data_idx == selected else curses.A_NORMAL
                    else:
                        attr = curses.A_BOLD if abs_line == 0 else curses.A_NORMAL
                    self.win.addstr(y, 2, line[:max_x - 4], attr)

                self.win.refresh()
                key = self.win.getch()

                if key == curses.KEY_UP:
                    if rows:
                        selected = (selected - 1) % len(rows)
                elif key == curses.KEY_DOWN:
                    if rows:
                        selected = (selected + 1) % len(rows)
                elif key in (10, 13):  # ENTER
                    if rows:
                        format_traynotify_metadata_table(rows, screen_width=max_x - 4,
                                                        selected_index=selected, show_popup=True, win=self.win, db_path=self.db_path)
                elif key in (27, ord("q")):
                    conn.close()
                    self.layout.change_footer("ESC: Salir, ↑/↓: Navegar, ENTER: Ver resumen de usuario, e: Exportar informacion del usuario")
                    return
        elif index == 10:  # Historial de navegador (Firefox)
            selected = 0
            scroll_offset = 0
            self.layout.change_footer("")

            # Cargamos de nuevo las filas para este usuario, ordenadas por última visita desc
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute(
                "SELECT url, title, visit_count, last_visit_date "
                "FROM firefox_history WHERE username=? AND COALESCE(visit_count,0) > 0 "
                "ORDER BY last_visit_date DESC NULLS LAST", (username,)
            )
            rows = cursor.fetchall()

            while True:
                self.win.clear()
                max_y, max_x = self.win.getmaxyx()
                self.win.box()

                title = " Historial de navegador (Firefox) "
                self.win.addstr(0, max(2, (max_x - len(title)) // 2), title, curses.A_BOLD)

                footer = " ↑/↓: Navegar  ENTER: Detalle  ESC/q: Salir "
                self.win.addstr(max_y - 1, max(2, (max_x - len(footer)) // 2), footer, curses.A_BOLD)

                tabla = format_firefox_history_table(rows, screen_width=max_x - 4)
                lineas = tabla.split("\n")

                header_lines = 2
                visible_height = max_y - 2
                total_lines = len(lineas)

                # Asegura selected dentro del rango de filas
                if rows:
                    selected = max(0, min(selected, len(rows) - 1))
                else:
                    selected = 0

                selected_line = selected + header_lines

                if selected_line < scroll_offset + header_lines:
                    scroll_offset = selected_line - header_lines
                elif selected_line >= scroll_offset + visible_height:
                    scroll_offset = selected_line - visible_height + 1

                max_scroll = max(0, total_lines - visible_height)
                scroll_offset = max(0, min(scroll_offset, max_scroll))

                visibles = lineas[scroll_offset:scroll_offset + visible_height]
                for i, line in enumerate(visibles):
                    y = i + 1
                    abs_line = scroll_offset + i
                    if abs_line >= header_lines:
                        data_idx = abs_line - header_lines
                        attr = curses.A_REVERSE if data_idx == selected else curses.A_NORMAL
                    else:
                        attr = curses.A_BOLD if abs_line == 0 else curses.A_NORMAL
                    self.win.addstr(y, 2, line[:max_x - 4], attr)

                self.win.refresh()
                key = self.win.getch()

                if key == curses.KEY_UP:
                    if rows:
                        selected = (selected - 1) % len(rows)
                elif key == curses.KEY_DOWN:
                    if rows:
                        selected = (selected + 1) % len(rows)
                elif key in (10, 13):  # ENTER
                    if rows:
                        format_firefox_history_table(rows, screen_width=max_x - 4,
                                                    selected_index=selected, show_popup=True, win=self.win)
                elif key in (27, ord("q")):
                    conn.close()
                    self.layout.change_footer("ESC: Salir, ↑/↓: Navegar, ENTER: Ver resumen de usuario, e: Exportar informacion del usuario")
                    return

        else:
            info = f" {section_titles[index]} \nUsuario: {username}\n\n"
            if not rows:
                info += "(Sin datos disponibles)"
            else:
                for row in rows:
                    if index == 5 and not self.show_system_entries:
                        if str(row[0]).lower().startswith("@shell32.dll") or str(row[0]).lower().startswith("@c:\\windows"):
                            continue
                    info += ", ".join(str(col) for col in row) + "\n"

        show_scrollable_popup(self.win, info, section_titles[index])
        self.layout.change_header("Informacion general de los usuarios disponibles")
        self.layout.change_footer("ESC: Salir, ↑/↓: Navegar, ENTER: Ver resumen de usuario, e: Exportar informacion del usuario")


    def _export_user_data(self, username):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        sections = [
            ("userassist", "Programas ejecutados desde Menú Inicio", "name, run_count, last_run_time"),
            ("recent_docs", "Documentos abiertos recientemente", "extension, document_name"),
            ("run_mru", "Comandos lanzados con Win+R", "order_key, command"),
            ("mountpoints2", "Dispositivos externos conectados", "key_name, volume_label, data"),
            ("open_save_mru", "Archivos recientes en diálogos Abrir/Guardar", "extension, entry_name, path"),
            ("muicache", "Programas visualizados en Explorer (MuiCache)", "entry_name, description"),
            ("shellbags", "ShellBags", "user, path, key_path, timestamp"),
            ("mru_entries", "MRU (archivos usados recientemente)", "user, mru_type, extension, file_name, key_path, timestamp"),
            ("traynotify_executables", "TrayNotify: ejecutables e información del systray", "user, source, exe_name, extension_type, suspicious, key_path, timestamp"),
            ("traynotify_metadata", "TrayNotify: metadatos de entradas del systray", "user, value_name, data, key_path, timestamp"),
            ("firefox_history", "Historial de navegador (Firefox)", "url, title, visit_count, last_visit_date")
        ]

        user_field_per_table = {
            "userassist": "username",
            "recent_docs": "username",
            "run_mru": "username",
            "mountpoints2": "username",
            "open_save_mru": "username",
            "muicache": "username",
            "shellbags": "user",
            "mru_entries": "user",
            "traynotify_executables": "user",
            "traynotify_metadata": "user",
            "firefox_history": "username"
        }

        output = f"Resumen forense de usuario: {username}\n\n"
        for table, title, fields in sections:
            campo_usuario = user_field_per_table.get(table, "username")
            cursor.execute(f"SELECT {fields} FROM {table} WHERE {campo_usuario}=?", (username,))
            rows = cursor.fetchall()
            output += f"== {title} ==\n"
            if not rows:
                output += "(Sin datos disponibles)\n"
            else:
                for row in rows:
                    if table == "muicache" and not self.show_system_entries:
                        if str(row[0]).lower().startswith("@shell32.dll") or str(row[0]).lower().startswith("@c:\\windows"):
                            continue

                    if table == "firefox_history":
                        # Orden según mapping: url, title, visit_count, last_visit_date
                        url, title, visit_count, last_visit_date = row
                        output += f"{url}, {title}, {visit_count}, {moz_prtime_to_str(last_visit_date)}\n"
                    else:
                        output += ", ".join(str(col) for col in row) + "\n"

            output += "\n"

        conn.close()

        os.makedirs(self.export_path, exist_ok=True)
        filename = f"{self.export_path}/{username}_forensic_report.txt"
        with open(filename, "w", encoding="utf-8") as f:
            f.write(output)

        show_scrollable_popup(self.win, f"Datos exportados correctamente a:\n{filename}", "Exportación exitosa")
        self.layout.change_header("Informacion general de los usuarios disponibles")
        self.layout.change_footer("ESC: Salir, ↑/↓: Navegar, ENTER: Ver resumen de usuario, e: Exportar informacion, s: Activar/Desactivar entradas del sistema en MuiCache")
